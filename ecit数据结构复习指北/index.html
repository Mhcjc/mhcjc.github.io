<!doctype html>
<html lang="en-us">
  <head>
    <title>ECIT数据结构复习指北 // Objectman</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.60.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://example.org/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ECIT数据结构复习指北"/>
<meta name="twitter:description" content="ECIT数据结构复习指北 ​	纯属娱乐，如果发现问题联系2024099381
数据结构的概念： ​	自行百度。
线性表的线性储存结构： 考点   线性表的插入： ① 将线性表的第i个数据元素到第n个元素之间的所有元素一次向后移动一个位置
②将元素item插入第i个位置
③修改表长为n&#43;1
注意移动的顺序，千万得从后面的开始移动不然会覆盖前面的元素。 arr[j] = arr[j&#43;1];
算法：
void INSERTLIST(int A[], int &amp;n, int i, int t) /*注意n的引用是为了标记数组元素个数，i为插入的位置，t为插入元素*/ { int j; if(n == MaxSize || i&lt;1 || i&gt;n&#43;1)	//判断数组是否已满， 以及i是否符合数组的大小  { cout&lt;&lt; &#34;数组已满或插入位置不正确&#34;&lt;&lt;endl; exit(0); } for(j = n-1; j&gt;= i-1; j--) A[j&#43;1] = A[j]; A[i-1] = t; n&#43;&#43;; }   线性表的删除： 与上面类似
不过须要注意的是可以直接用后面的元素覆盖前面的元素就可以了 arr[i] = arr[i&#43;1]"/>

    <meta property="og:title" content="ECIT数据结构复习指北" />
<meta property="og:description" content="ECIT数据结构复习指北 ​	纯属娱乐，如果发现问题联系2024099381
数据结构的概念： ​	自行百度。
线性表的线性储存结构： 考点   线性表的插入： ① 将线性表的第i个数据元素到第n个元素之间的所有元素一次向后移动一个位置
②将元素item插入第i个位置
③修改表长为n&#43;1
注意移动的顺序，千万得从后面的开始移动不然会覆盖前面的元素。 arr[j] = arr[j&#43;1];
算法：
void INSERTLIST(int A[], int &amp;n, int i, int t) /*注意n的引用是为了标记数组元素个数，i为插入的位置，t为插入元素*/ { int j; if(n == MaxSize || i&lt;1 || i&gt;n&#43;1)	//判断数组是否已满， 以及i是否符合数组的大小  { cout&lt;&lt; &#34;数组已满或插入位置不正确&#34;&lt;&lt;endl; exit(0); } for(j = n-1; j&gt;= i-1; j--) A[j&#43;1] = A[j]; A[i-1] = t; n&#43;&#43;; }   线性表的删除： 与上面类似
不过须要注意的是可以直接用后面的元素覆盖前面的元素就可以了 arr[i] = arr[i&#43;1]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/ecit%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97/" />
<meta property="article:published_time" content="2019-11-30T16:39:44+08:00" />
<meta property="article:modified_time" content="2019-11-30T16:39:44+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="http://example.org/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>Objectman</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">ECIT数据结构复习指北</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 30, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="ecit"><strong>ECIT数据结构复习指北</strong></h1>
<p>​																				纯属娱乐，如果发现问题联系2024099381</p>
<h2 id="heading">数据结构的概念：</h2>
<p>​						自行百度。</p>
<h2 id="heading1">线性表的线性储存结构：</h2>
<h3 id="heading2">考点</h3>
<ol>
<li>
<h5 id="heading3">线性表的插入：</h5>
<p>① 将线性表的第i个数据元素到第n个元素之间的所有元素一次向后移动一个位置</p>
<p>②将元素item插入第i个位置</p>
<p>③修改表长为n+1</p>
<p>注意移动的顺序，千万得从后面的开始移动不然会覆盖前面的元素。         arr[j] = arr[j+1];</p>
<p>算法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">INSERTLIST</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>n, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> t)  <span style="color:#75715e">/*注意n的引用是为了标记数组元素个数，i为插入的位置，t为插入元素*/</span>
{
    <span style="color:#66d9ef">int</span> j;
    <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">=</span><span style="color:#f92672">=</span> MaxSize <span style="color:#f92672">|</span><span style="color:#f92672">|</span> i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> i<span style="color:#f92672">&gt;</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)		<span style="color:#75715e">//判断数组是否已满， 以及i是否符合数组的大小
</span><span style="color:#75715e"></span>    {
        cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">数组已满或插入位置不正确</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl;
        exit(<span style="color:#ae81ff">0</span>);
    }
    <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">-</span><span style="color:#f92672">-</span>)
        A[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> A[j];
    A[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> t;
    n<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
</code></pre></div></li>
<li>
<h5 id="heading4">线性表的删除：</h5>
<p>与上面类似</p>
<p>不过须要注意的是可以直接用后面的元素覆盖前面的元素就可以了         arr[i] = arr[i+1]</p>
</li>
<li>
<h5 id="heading5">线性表的查找：</h5>
<p>for循环遍历就好了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LOCATE</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> t)  
{
    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">if</span>(A[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> item)
            <span style="color:#66d9ef">return</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;      	<span style="color:#75715e">//查找成功，返回位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;			<span style="color:#75715e">//查找失败返回-1
</span><span style="color:#75715e"></span>}
   
</code></pre></div></li>
<li>
<h5 id="heading6">删除表中重复出现的元素：</h5>
<p>体现为   遍历+查找+删除</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PUGRGE</span>(<span style="color:#66d9ef">int</span>[] A, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>n)
{
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>n)				<span style="color:#75715e">//标记要遍历查找删除的元素
</span><span style="color:#75715e"></span>    {
        j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span>(j<span style="color:#f92672">&lt;</span>n)			<span style="color:#75715e">//遍历
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(A[j] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> A[i])
                DELETELIST(A, n, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);	<span style="color:#75715e">//删除
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span>
                j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        }
        i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    }
} <span style="color:#75715e">//算法复杂度O(n²)
</span></code></pre></div></li>
<li>
<h5 id="heading7">对线性表中的元素进行排序：</h5>
<p>跳转至冒泡排序</p>
</li>
</ol>
<h2 id="heading8">堆栈的概念及其操作</h2>
<p>堆栈简称栈，一种只允许在表的一端进行插入和删除的线性表。</p>
<h2 id="heading9">队列的概念及其操作</h2>
<p>简称队，是只允许在表的一端进行出入操作，而在表的另一端进行删除操作的线性表。</p>
<h2 id="heading10">树二叉树</h2>
<h3 id="-------------ps----145">基本术语：    									~Ps:    145</h3>
<h3 id="----------ps----146">树的性质：										~Ps:    146</h3>
<ol>
<li>
<h6 id="-1">非空树的节点总数等于树中所有结点的度之和加 1</h6>
</li>
<li>
<h6 id="ki-ki1-">度为k的非空树的第i层最多有 k^(i+1) 个结点</h6>
</li>
<li>
<h6 id="hk-kh1k1-">深度为h的k叉树最多有 (k^h-1)/k-1 个结点</h6>
</li>
</ol>
<h2 id="heading11">二叉树</h2>
<p>​															~Ps:    150</p>
<h3 id="heading12">两种形态的二叉树</h3>
<ol>
<li>满二叉树</li>
<li>完全二叉树</li>
</ol>
<h3 id="-----------------------------------------------------------ps---------152">二叉树的性质                                                           ~ps:         152</h3>
<ol>
<li>具有n个结点的非空二叉树有且仅有n-1个分支</li>
<li>非空二叉树的第 i 层最多有 2^（i-1）个结点</li>
<li>深度为h的非空二叉树最多有 2^h - 1个结点</li>
<li>在任意非空二叉树中若叶结点的数目为n0，度为2的结点数目为n2，则有关系 n0 = n2 +1 成立</li>
<li>具有n(n&gt;0)个结点的完全二叉树的深度h = （log 以 2 为底 n的对数） +1</li>
<li>父结点与子节点的关系          ~Ps 153</li>
</ol>
<h3 id="heading13">二叉树与树，树林之间的转换</h3>
<p>简单理解：二叉树的左儿子是在树或树林中该结点的子结点，右儿子为兄弟结点。（我把你当兄弟，你却要当我爸爸）</p>
<h3 id="heading14">二叉树的储存结构</h3>
<p>深入理解，请参考书本</p>
<h3 id="--------------------------------------------------------ps----163">二叉树的遍历                                                        ~ps    163</h3>
<p><!-- raw HTML omitted --></p>
<p>前序遍历结果：ABDECF</p>
<p>中序遍历结果：DBEACF</p>
<p>后序遍历结果：DEBFCA</p>
<h3 id="-------------------------------------------------------------------ps----------170">二叉树的恢复                                                                   ~ps          170</h3>
<p>根据前序和中序 或者后序和中序 才能复原二叉树，要恢复二叉树必须知道中序序列，只是知道前序和后序，不能恢复二叉树，因为不知道中序序列无法获知根节点的左右子树位置，少了中序遍历不行</p>
<h5 id="heading15">恢复二叉树的大概步骤：</h5>
<p>拿上图举例</p>
<ol>
<li>先从前序或后续遍历中找出第一个根结点  A</li>
<li>再从中序遍历里将结点分为两棵子树   左子树 DBE, 右子树 CF</li>
<li>重复上述步骤</li>
</ol>
<h2 id="-------------------------------------------------ps-199">哈夫曼树及其应用                                                 ~ps 199</h2>
<h2 id="heading16">图</h2>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
